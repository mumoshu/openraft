use bytes::Bytes;
use std::collections::BTreeSet;
use std::{collections::HashMap, time::SystemTimeError};
use serde::{Deserialize, Serialize};

use crate::httprouter;
use crate::NodeId;
use crate::typ::ClientWriteResponse;

type Key = String;
type Val = String;

// Ver is a version number, which is a mostly monotonically increasing number.
// It is used to determine the order of transactions.
//
// Theoretically this can be generated by a monotonically increasing counter,
// such as a Lamport clock or a vector clock, or a timestamp.
// We currently use the system clock to generate the version number as it is simple,
// not requiring any coordination between nodes, and is good enough for our purposes.
//
// In practice, monotonicity is not guaranteed due to clock drifts and other factors when
// we use the system clock to generate the version number.
// However, the transactions are still linearizable, even if the version numbers are not strictly monotonically increasing.
// That's because our transaction protocol uses dependency tracking to ensure that transactions
// are linearizable. Transactions coming from a node with higher clock drift will be aborted
// and retried more often though.
type Ver = u128;

// Txn is a transaction, which contains the keys to be read at the read version,
// and the keys and values to be written at the commit version (which is determined at the time of commit)
#[derive(Serialize, Deserialize, Clone)]
pub struct Txn {
    // keys_and_values is a map of keys to values to be written via this transaction.
    pub keys_and_values: HashMap<Key, Val>,
    pub read_conflict_ranges: Vec<(Key, Key)>,
    pub write_conflict_ranges: Vec<(Key, Key)>,
    pub read_version: Option<Ver>,

    //// We don't have the commit_version within this struct,
    //// because the commit_version is not known when the transaction is created,
    //// and is unneeded until the transaction is committed.
    // pub commit_version: u128,
}

// Client is a client to a RaftKV cluster.
// It connects to one of the RaftKV nodes via RaftKV HTTP API.
// Client provides both high-level and low-level APIS.
// The high-level APIs provides a key-value store with linearizable read and write operations.
// The low-level APIs provide a way to call the RaftKV HTTP APIs directly.
pub struct Client {
    addr: String,
}


#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct TransactionCommitResponse {
}

// GetError is an error type for get operation.
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct GetError(String);

// GetResponse is a response type for get operation.
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct GetResponse {
    pub value: Option<String>,
}

// ScanError is an error type for scan operation.
#[derive(Serialize, Deserialize, Debug)]
pub struct ScanError(String);

// TransactionCommitError is an error type for transaction commit.
#[derive(Debug, PartialEq)]
pub struct TransactionCommitError(String);

// SendError is an error type for sending requests.
#[derive(Debug)]
pub struct SendError(String);

// InitError is an error type for init operation.
#[derive(Debug, PartialEq)]
pub struct InitError(String);

#[derive(Serialize, Deserialize, Debug)]
pub struct InitRequest {}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct InitResponse {}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct AddFollowerResponse {}

#[derive(Debug, PartialEq)]
pub struct AddFollowerError(String);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub struct ChangeMembershipResponse {}

#[derive(Debug, PartialEq)]
pub struct ChangeMembershipError(String);

impl Client {
    // NewClient returns a new RaftKV client.
    pub fn new(addr: String) -> Self {
        Self { addr }
    }

    // KVScan scans keys in the range of start_key and end_key.
    pub async fn kv_scan(
        &self,
        start_key: Key,
        end_key: Key,
    ) -> Result<Vec<(Key, Val)>, ScanError> {
        let path = "scan";
        let v = self.get_version().await.unwrap();
        let req = crate::Request::Scan {
            start_key: start_key,
            end_key: end_key,
            version: v,
        };
        let res = self.send::<crate::Request, Vec<(Key, Val)>>(path, req).await;
        match res {
            Ok(v) => Ok(v),
            Err(e) => Err(ScanError(e.0)),
        }
    }

    //
    // Management APIs
    //

    pub async fn init(&self) -> Result<InitResponse, InitError> {
        let path = "init";
        let req = InitRequest {};
        self.send::<InitRequest, ()>(path, req).await.map_err(|e|
            InitError(e.0)
        ).map(|_| InitResponse {})
    }
    
    pub async fn add_learner(&self, node_id: NodeId, addr: String) -> Result<AddFollowerResponse, AddFollowerError> {
        let path = "add-learner";
        let req = (node_id, addr);
        self.send::<(NodeId, String), ClientWriteResponse>(path, req).await.map_err(|e|
            AddFollowerError(e.0)
        ).map(|_| AddFollowerResponse {})
    }

    pub async fn change_membership(&self, nodes: BTreeSet<NodeId>) -> Result<ChangeMembershipResponse, ChangeMembershipError> {
        let path = "change-membership";
        let req = nodes;
        self.send::<BTreeSet<NodeId>, ClientWriteResponse>(path, req).await.map_err(|e|
            ChangeMembershipError(e.0)
        ).map(|_| ChangeMembershipResponse {})
    }

    //
    // Transactional Key-Value Store APIs
    //

    // TxnNew creates a new transaction.
    pub fn txn_new(&self) -> Txn {
        Txn {
            keys_and_values: HashMap::new(),
            read_conflict_ranges: vec![],
            write_conflict_ranges: vec![],
            read_version: None,
        }
    }

    // txn_get gets the value for a key.
    pub async fn txn_get(&self, txn: &mut Txn, key: Key) -> Result<GetResponse, GetError> {
        let read_conflict_range = (key.clone(), key.clone());
        txn.read_conflict_ranges.push(read_conflict_range);

        let read_version = self.lazy_read_version(txn).await;

        let req = crate::Request::Get { key: key, version: read_version };
        self.send::<crate::Request, crate::Response>("local_read", req).await
            .map(|r| GetResponse { value: r.value })
            .map_err(|e| GetError(e.0))
    }

    // txn_consistent_get gets the value for a key.
    pub async fn txn_consistent_get(&self, txn: &mut Txn, key: Key) -> Result<GetResponse, GetError> {
        let read_conflict_range = (key.clone(), key.clone());
        txn.read_conflict_ranges.push(read_conflict_range);

        let read_version = self.lazy_read_version(txn).await;

        let req = crate::Request::Get { key: key, version: read_version };
        self.send::<crate::Request, crate::Response>("consistent_read", req).await
            .map(|r| GetResponse { value: r.value })
            .map_err(|e| GetError(e.0))
    }

    // txn_put puts a key-value pair into the store.
    pub fn txn_put(&self, txn: &mut Txn, key: Key, value: Key) {
        let write_conflict_range = (key.clone(), key.clone());
        txn.write_conflict_ranges.push(write_conflict_range);

        txn.keys_and_values.insert(key, value);
    }

    // txn_commit commits the transaction.
    pub async fn txn_commit(&self, txn: Txn) -> Result<TransactionCommitResponse, TransactionCommitError> {
        let path = "write";
        let write_version = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos();
        let req = crate::Request::Commit {
            keys_and_values: txn.keys_and_values.clone(),
            read_conflict_ranges: txn.read_conflict_ranges.clone(),
            write_conflict_ranges: txn.write_conflict_ranges.clone(),
            read_version: txn.read_version.unwrap(),
            write_version: write_version,
        };
        self.send::<crate::Request, TransactionCommitResponse>(path, req).await.map_err(|e|
            TransactionCommitError(e.0)
        )
    }

    //
    // Internal APIs
    //

    // lazy_read_version returns the read version associated to the transaction if it is already retrieved
    // and cached earlier. Otherwise, it tries to get the read version, caches and returns it.
    pub async fn lazy_read_version(&self, txn: &mut Txn) -> u128 {
        // TODO make this thread-safe
        if txn.read_version.is_none() {
            let read_version = self.get_version().await.unwrap();
            txn.read_version = Some(read_version);
        }
        txn.read_version.unwrap()
    }

    // get_version gets the read/write version from the system clock in nanoseconds.
    // This doesn't contact the RaftKV cluster and instead uses the local system clock.
    pub async fn get_version(&self) -> Result<u128, SystemTimeError> {
        // TODO Enable injecting a simulated clock for testing.

        // Get the current system clock
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_nanos())
    }

    pub async fn send<Req, Resp>(&self, path: &str, req: Req) -> Result<Resp, SendError>
    where
        Req: Serialize,
        Resp: serde::de::DeserializeOwned,
    {
        let client = reqwest::Client::new();
        let url = format!("{}/{}", self.addr, path);
        let resp = client.post(url).json(&req).send().await.unwrap();
        let res: Resp =
            resp.json().await.map_err(|e| SendError(format!("send {:?}: failed to parse response: {:?}", path, e)))?;
        Ok(res)
    }
}

mod tests {
    use super::*;
    use tokio::runtime::Runtime;
    use env_logger;
    use env_logger::Env;

    #[test]
    fn test_kv_get_put_1node() {
        let addr = "http://localhost:11000";
        let rt = Runtime::new().unwrap();

        // Start the RaftKV cluster
        rt.spawn(run_raftkv_node(1, "localhost:11000"));

        // Start the test session that connects to the RaftKV cluster
        let addr = addr.clone();
        rt.block_on(async {
            // Wait for server to start up.
            tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;

            let client = Client::new(addr.to_string());

            let res = client.init().await;
            assert_eq!(res, Ok(InitResponse {}));

            let key = String::from("key");
            let value = String::from("value");

            let mut txn = client.txn_new();
            let res = client.txn_get(&mut txn, key.clone()).await;
            assert_eq!(res, Ok(GetResponse { value: None }));

            client.txn_put(&mut txn, key.clone(), value.clone());
            let res = client.txn_commit(txn).await;
            assert_eq!(res, Ok(TransactionCommitResponse {}));

            // Wait for the commit to be applied.
            // tokio::time::sleep(tokio::time::Duration::from_millis(2000)).await;

            let mut txn = client.txn_new();
            let res = client.txn_consistent_get(&mut txn, key.clone()).await;
            assert_eq!(res, Ok(GetResponse { value: Some(value.clone()) }));
        });

        rt.shutdown_timeout(std::time::Duration::from_secs(1));
    }

    #[test]
    fn test_kv_get_put_3nodes() {
        env_logger::init_from_env(Env::default().default_filter_or("trace"));

        let addr = "http://localhost:11000";
        let rt = Runtime::new().unwrap();

        // Start the RaftKV cluster of 3 nodes
        rt.spawn(run_raftkv_node(1, "localhost:11000"));
        rt.spawn(run_raftkv_node(2, "localhost:11001"));
        rt.spawn(run_raftkv_node(3, "localhost:11002"));

        // Start the test session that connects to the RaftKV cluster
        let addr = addr.clone();
        rt.block_on(async {
            // Wait for server to start up.
            tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;

            let client = Client::new(addr.to_string());

            let res = client.init().await;
            assert_eq!(res, Ok(InitResponse {}));

            let res = client.add_learner(2, "localhost:11001".to_string()).await;
            assert_eq!(res, Ok(AddFollowerResponse {}));

            let res = client.add_learner(3, "localhost:11002".to_string()).await;
            assert_eq!(res, Ok(AddFollowerResponse {}));

            let nodes = BTreeSet::from([1, 2, 3]);
            let res = client.change_membership(nodes).await;
            assert_eq!(res, Ok(ChangeMembershipResponse {}));

            let key = String::from("key");
            let value = String::from("value");

            let mut txn = client.txn_new();
            let res = client.txn_get(&mut txn, key.clone()).await;
            assert_eq!(res, Ok(GetResponse { value: None }));

            client.txn_put(&mut txn, key.clone(), value.clone());
            let res = client.txn_commit(txn).await;
            assert_eq!(res, Ok(TransactionCommitResponse {}));

            // Wait for the commit to be applied.
            // tokio::time::sleep(tokio::time::Duration::from_millis(2000)).await;

            let mut txn = client.txn_new();
            let res = client.txn_consistent_get(&mut txn, key.clone()).await;
            assert_eq!(res, Ok(GetResponse { value: Some(value.clone()) }));
        });

        rt.shutdown_timeout(std::time::Duration::from_secs(1));
    }

    async fn run_raftkv_node(node_id: NodeId, addr: &str) {
        let router = httprouter::HttpRouter::default();
        let (_raft, app) = crate::new_http_raft(node_id, router, String::from(addr)).await;
        let res = app.run().await;
        res.unwrap();
    }
}